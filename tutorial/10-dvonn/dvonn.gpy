# Public.board = {(i,j): [piece]}, with piece player number or -1 for a red ring.

num_players = 2

class Game:
	def run(self): # {{{
		yield from self.setup()
		yield from self.main()
		scores = [sum(self.Public.board[pos] for pos in self.Public.board if self.Public.board[pos][-1] == player) for player in range(2)]
		return scores
	# }}}
	def setup(self): # {{{
		self.Public.board = {}
		for i in range(11):
			for j in range(5):
				if 2 <= i + j <= 12:
					self.Public.board[(i, j)] = []
		for t in range(49):
			player = t & 1
			self.players[player].Private.state = 'Place a piece'
			self.players[1 - player].Private.state = 'Wait for your turn'
			# Get a position from alternating players, which doesn't have a piece on it yet.
			p = (yield from self.get_pos(player, 'setup', lambda pos: len(self.Public.board[pos]) == 0))
			self.Public.board[p].append(-1 if t <= 3 else player)
	# }}}
	def main(self): # {{{
		while True:
			for player in range(2):
				options = self.get_options(player)
				if len(options) == 0:
					return
				self.players[1 - player].Private.state = 'Wait for your turn'
				self.players[player].Private.state = 'Choose a piece to move'
				self.players[player].options = options
				src = (yield from get_pos(player, 'pick', lambda p: p in options))
				self.players[player].Private.state = 'Choose where to move to'
				dst = (yield from get_pos(player, 'place', lambda p: p in options[src]))
				self.Public.board[dst].extend(self.Public.board[src])
				self.Public.board[src] = []
				# Remove dead groups.
				queue = [pos for pos in self.Public.board.keys() if -1 in self.Public.board[pos]]
				towers = [pos in self.Public.board.keys() if pos not in queue and len(self.Public.board[pos]) > 0]
				while len(queue) > 0:
					current = queue.pop()
					for i, j in ((1, 0), (0, 1), (-1, 1)):
						for d in (1, -1):
							target = (current[0] + d * i, current[1] + d * j)
							if target in towers:
								queue.append(target)
								towers.remove(target)
				for pos in towers:
					self.Public.board.pop(pos)
	# }}}
	def get_pos(self, player, command, acceptable): # {{{
		while True:
			pos = tuple((yield {command: player})['args'][0])
			if pos in self.Public.board and acceptable(pos):
				return pos
	# }}}
	def get_options(self, player): # {{{
		ret = {}
		for pos in self.Public.board:
			h = len(self.Public.board[pos])
			if h == 0:
				continue
			if self.Public.board[pos][-1] != player:
				continue
			option = []
			allowed = False
			for i, j in ((1, 0), (0, 1), (-1, 1)):
				for d in (1, -1):
					# Update allowed based on direct neighbors.
					target = (pos[0] + d * i, pos[1] + d * j)
					if target not in self.Public.board:
						continue
					if len(self.Public.board[target]) == 0:
						allowed = True
					# Check target.
					target = (pos[0] + d * i * h, pos[1] + d * j * h)
					if target not in self.Public.board:
						continue
					if len(self.Public.board[target]) == 0:
						continue
					option.append(target)
			if allowed and len(option) > 0:
				ret[pos] = option
		return ret
	# }}}

# vim: set filetype=python foldmethod=marker :
